#if LINUX
using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Diagnostics;
using SharpHook;
using SharpHook.Data;
using static Keysharp.Core.Common.Keyboard.KeyboardUtils;
using static Keysharp.Core.Common.Keyboard.VirtualKeys;
using static Keysharp.Core.Linux.SharpHookKeyMapper;
using static Keysharp.Core.Common.Keyboard.KeyboardMouseSender;

namespace Keysharp.Core.Linux
{
	/// <summary>
	/// Linux implementation of HookThread.
	/// Listens with SharpHook; uses XGrabKey for hotkeys which must be blocked (no tilde).
	/// </summary>
	internal class LinuxHookThread : Keysharp.Core.Common.Threading.HookThread
	{
		private static readonly bool HookDisabled = ShouldDisableHook();
		[Conditional("DEBUG")]
		private static void DebugLog(string message) => Console.WriteLine(message);

		// --- SharpHook ---
		private SimpleGlobalHook? globalHook;
		private Task? hookRunTask;

		// Cached on/off
		private volatile bool keyboardEnabled;
		private volatile bool mouseEnabled;

		// Custom modifier tracking (e.g. CapsLock & a)
		private CustomPrefixState customPrefix;
		private IndicatorSnapshot indicatorSnapshot = new(false, false, false);
		private readonly Dictionary<uint, int> ignoreNextVk = new();

		private readonly struct IndicatorSnapshot
		{
			public readonly bool Caps;
			public readonly bool Num;
			public readonly bool Scroll;
			public IndicatorSnapshot(bool caps, bool num, bool scroll)
			{
				Caps = caps; Num = num; Scroll = scroll;
			}
		}

		private readonly Dictionary<uint, bool> customPrefixSuppress = new();
		private readonly Dictionary<uint, List<(int keycode, uint mods)>> dynamicPrefixGrabs = new();
		private readonly object injectedLock = new();
		private bool injectedActive;
		private uint activeHotkeyVk;
		private bool activeHotkeyDown;
		private readonly bool[] logicalKeyState = new bool[VK_ARRAY_COUNT];
		internal uint ActiveHotkeyVk => activeHotkeyVk;
		internal bool SendInProgress => sendInProgress;

		private readonly Dictionary<uint, int> injectedHeld = new();


		// Hotstring press-time trigger helpers
		private uint hsIgnoreNextReleaseFor = 0;   // vk of the end key we’ll ignore on real KeyUp
		private bool hsSuppressTypedForEnd = false; // skip KeyTyped generated by the armed end key
		private bool hsSuppressTypedForHotkeyOnce = false; // skip next KeyTyped generated by suppressed hotkey suffix
		private bool hsSuppressTypedForHotkeyPrefix = false; // suppress KeyTyped while a blocked custom prefix is held
		private ulong lastTypedExtraInfo = (ulong)(SendLevelMax + 1); // tracks last KeyTyped extra info for InputLevel checks

		private static CaseConformModes ComputeCaseMode(HotstringDefinition hs, List<char> buf)
		{
			if (!hs.conformToCase || buf.Count == 0)
				return CaseConformModes.None;

			var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(buf);
			int end = span.Length - (hs.endCharRequired ? 1 : 0);
			if (end <= 0)
				return CaseConformModes.None;

			int start = Math.Max(0, end - hs.str.Length);
			int cap = 0, up = 0;

			for (int i = start; i < end; i++)
			{
				char c = span[i];
				if (char.IsLetter(c)) { cap++; if (char.IsUpper(c)) up++; }
			}

			if (cap == 0)
				return CaseConformModes.None;

			if (up == cap)
				return CaseConformModes.AllCaps;
			if (up == 0)
				return CaseConformModes.None;
			if (char.IsLetter(span[start]) && char.IsUpper(span[start]))
				return CaseConformModes.FirstCap;

			return CaseConformModes.None;
		}

		// Hotstring arming state
		private bool hsArmed;   // any end-keys are armed right now?

		// Each armed end-key we grab (base grab; variants for Caps/NumLock are stored in hsActiveGrabVariants)
		private readonly List<ArmedEnd> hsArmedEnds = new();

		private readonly List<(int keycode, uint mods)> hsActiveGrabVariants = new(); // to ungrab fast

		private struct ArmedEnd
		{
			public int Keycode;             // X11 keycode we grabbed
			public uint XModsBase;          // base X11 modifiers used for grab (without Lock/NumLock variants)
			public uint Vk;                 // engine VK for that end key
			public char EndChar;            // actual end character we will append to the hs buffer
			public bool NeedShift;          // required to produce EndChar
			public bool NeedAltGr;          // required to produce EndChar (ISO_Level3 / Mod5)
		}

		private enum LockKeyKind
		{
			None,
			CapsLock,
			NumLock,
			ScrollLock
		}

		private struct CustomPrefixState
		{
			public uint Vk;
			public bool Suppressed;
			public LockKeyKind LockKind;
			public bool LockState;
			public bool LockCaptured;
			public bool Used;           // any other key pressed while held?
			public bool FireOnRelease;  // whether to fire the prefix hotkey on release
			public void Reset()
			{
				Vk = 0;
				Suppressed = false;
				LockKind = LockKeyKind.None;
				LockState = false;
				LockCaptured = false;
				Used = false;
				FireOnRelease = false;
			}
		}

		// --- Simple hotkey map for Linux (vk + LR-mods, up/down) ---
		private readonly object hkLock = new();
		private readonly List<LinuxHotkey> linuxHotkeys = new(); // minimal matcher
		private long sendInProgressLevel;
		internal bool sendUngrabActive;

		private struct LinuxHotkey
		{
			public uint IdWithFlags;
			public uint Vk;
			public uint ModifiersLR; // LR-specific mask (MOD_* bits)
			public uint ModifierVK;   // custom prefix VK (0 if none)
			public bool KeyUp;       // is a key-up hotkey
			public bool PassThrough; // ~ tilde present => don't grab
			public bool AllowExtra;  // wildcard (*) hotkey: allow extra modifiers
		}

		// --- X11 grab state (only if X available) ---
		private IntPtr xDisplay = IntPtr.Zero;
		private IntPtr xRoot = IntPtr.Zero;
		private readonly List<(int keycode, uint mods)> activeGrabs = new();
		private readonly List<(int keycode, uint mods)> activeDynamicGrabs = new();
		private bool sendInProgress;
		internal struct GrabSnapshot
		{
			public bool Active;
			public List<(int keycode, uint mods)> Grabs;
			public List<(int keycode, uint mods)> DynamicGrabs;
		}

		private bool IsX11Available
		{
			get
			{
				if (xDisplay != IntPtr.Zero)
					return true;
				try
				{
					xDisplay = XOpenDisplay(IntPtr.Zero);
					if (xDisplay != IntPtr.Zero)
						xRoot = XDefaultRootWindow(xDisplay);
				}
				catch { xDisplay = IntPtr.Zero; xRoot = IntPtr.Zero; }
				return xDisplay != IntPtr.Zero && xRoot != IntPtr.Zero;
			}
		}

		internal LinuxHookThread()
		{
			kbdMsSender = new LinuxKeyboardMouseSender();
		}

		// -------------------- lifecycle --------------------
		protected internal override void DeregisterHooks()
		{
			StopGlobalHook();
			UngrabAll();
		}

		public override void SimulateKeyPress(uint key)
			=> kbdMsSender.SendKeyEvent(KeyEventTypes.KeyDownAndUp, key, 0, 0, false, 0);

		// -------------------- enable/disable --------------------

		internal override void AddRemoveHooks(HookType hooksToBeActive, bool changeIsTemporary = false)
		{
			StartGlobalHookIfNeeded(hooksToBeActive & (HookType.Keyboard | HookType.Mouse));
		}

		internal override void ChangeHookState(List<HotkeyDefinition> hk, HookType whichHook, HookType whichHookAlways)
		{
			// 1) Start/stop global listener according to request:
			var requested = (whichHook | whichHookAlways) & (HookType.Keyboard | HookType.Mouse);
			StartGlobalHookIfNeeded(requested);

			// 2) Rebuild minimal hotkey matcher + X11 grabs for blocking hotkeys:
			lock (hkLock)
			{
				linuxHotkeys.Clear();
				customPrefixSuppress.Clear();
				dynamicPrefixGrabs.Clear();
				UngrabDynamic();
				UngrabAll();

				if (hk != null)
				{
					foreach (var def in hk)
					{
						var entry = new LinuxHotkey
						{
							IdWithFlags = def.keyUp ? (def.id | HotkeyDefinition.HOTKEY_KEY_UP) : def.id,
							Vk = def.vk,
							ModifiersLR = def.modifiersConsolidatedLR,
							ModifierVK = def.modifierVK,
							KeyUp = def.keyUp,
							PassThrough = (def.noSuppress & HotkeyDefinition.AT_LEAST_ONE_VARIANT_HAS_TILDE) != 0,
							AllowExtra = def.allowExtraModifiers
						};
						linuxHotkeys.Add(entry);

						if (def.modifierVK != 0)
						{
							// By default, a custom prefix is suppressed unless the tilde prefix was used.
							var suppressPrefix = (def.noSuppress & HotkeyDefinition.NO_SUPPRESS_PREFIX) == 0;

							if (customPrefixSuppress.TryGetValue(def.modifierVK, out var suppressExisting))
								customPrefixSuppress[def.modifierVK] = suppressExisting || suppressPrefix;
							else
								customPrefixSuppress[def.modifierVK] = suppressPrefix;
						}

						// XGrabKey only when we must block (no tilde), and only if X11 is available.
						if (!entry.PassThrough && IsX11Available && entry.Vk != 0)
						{
							var modsForGrab = entry.ModifiersLR;
							bool? neutral = null;
							if (entry.ModifierVK != 0)
								modsForGrab |= KeyToModifiersLR(entry.ModifierVK, 0, ref neutral);

							// For custom prefixes that aren't real modifiers, grab the suffix only while the prefix is held.
							if (entry.ModifierVK != 0 && modsForGrab == 0)
							{
								if (TryMapToXGrab(entry.Vk, modsForGrab, out var keycode, out var mods))
								{
									if (!dynamicPrefixGrabs.TryGetValue(entry.ModifierVK, out var list))
										dynamicPrefixGrabs[entry.ModifierVK] = list = new();
									list.Add((keycode, mods));
								}
							}
							else if (TryMapToXGrab(entry.Vk, modsForGrab, out var keycode, out var mods))
							{
								if (entry.AllowExtra)
									GrabKeyWithExtraModifiers(keycode, mods);
								else
									GrabKey(keycode, mods);
							}
						}
					}

					if (IsX11Available)
					{
						foreach (var kvp in customPrefixSuppress)
						{
							if (!kvp.Value) continue; // tilde allows the prefix to pass through
							if (TryMapToXGrab(kvp.Key, 0, out var prefixKeycode, out _))
								GrabKeyVariantsInto(prefixKeycode, AnyModifier, activeGrabs, anyModifier: true);
						}
					}
				}
			}
		}

		internal override void Unhook() => DeregisterHooks();
		internal override void Unhook(nint hook) => DeregisterHooks();

		private void StartGlobalHookIfNeeded(HookType req)
		{
			if (HookDisabled)
			{
				StopGlobalHook();
				KeysharpEnhancements.OutputDebugLine("Linux hook disabled via KEYSHARP_DISABLE_HOOK=1.");
				return;
			}

			keyboardEnabled = (req & HookType.Keyboard) != 0;
			mouseEnabled = (req & HookType.Mouse) != 0;
			kbdHook = keyboardEnabled ? 1 : 0;   // sentinel so HasKbdHook() reports correctly on Linux
			mouseHook = mouseEnabled ? 1 : 0;

			if (!keyboardEnabled && !mouseEnabled)
			{
				StopGlobalHook();
				return;
			}

			// Already running? done.
			if (globalHook != null && globalHook.IsRunning)
				return;

			StopGlobalHook(); // clean restart

			globalHook = new SimpleGlobalHook();

			// keyboard
			globalHook.KeyPressed += OnKeyPressed;
			globalHook.KeyReleased += OnKeyReleased;
			globalHook.KeyTyped += OnKeyTyped;

			// mouse (minimal plumbing for future parity)
			globalHook.MousePressed += OnMousePressed;
			globalHook.MouseReleased += OnMouseReleased;
			globalHook.MouseMoved += (_, __) => { if (!mouseEnabled) return; /* TODO */ };
			globalHook.MouseWheel += OnMouseWheel;

			// Initialize modifier state from current logical snapshot to avoid stale startup values.
			if (TryQueryKeymap(out var km))
			{
				// Clear first
				System.Array.Clear(physicalKeyState, 0, physicalKeyState.Length);

				// Populate physicalKeyState from the keymap bits
				for (int keycode = 8; keycode < 256; keycode++)
				{
					var byteIndex = keycode >> 3;
					var bitMask = 1 << (keycode & 7);
					if ((km[byteIndex] & bitMask) == 0) continue;

					// Translate keycode to keysym -> VK.
					var ks = XKeycodeToKeysym(xDisplay, keycode, 0);
					if (ks == 0) continue;
					var vk = VkFromKeysym((ulong)ks);
					if (vk != 0 && vk < physicalKeyState.Length)
						physicalKeyState[vk] = StateDown;
				}

				// Derive modifiers from keymap for logical masks
				if (TryQueryModifierLRState(out var modsInit, km))
				{
					kbdMsSender.modifiersLRPhysical = modsInit;
					kbdMsSender.modifiersLRLogical = modsInit;
					kbdMsSender.modifiersLRLogicalNonIgnored = modsInit;
				}
			}

			_ = RefreshIndicatorSnapshot();
			hookRunTask = globalHook.RunAsync();
			// Ensure hook flags stay set even after (re)start.
			kbdHook = keyboardEnabled ? 1 : 0;
			mouseHook = mouseEnabled ? 1 : 0;
		}

		private void StopGlobalHook()
		{
			try { globalHook?.Dispose(); } catch { }
			try { if (hookRunTask != null && !hookRunTask.IsCompleted) hookRunTask.Wait(50); } catch { }
			globalHook = null;
			hookRunTask = null;

			System.Array.Clear(physicalKeyState, 0, physicalKeyState.Length);
			UngrabDynamic();
			kbdMsSender.modifiersLRLogical = 0;
			kbdMsSender.modifiersLRLogicalNonIgnored = 0;
			kbdMsSender.modifiersLRPhysical = 0;
			lock (ignoreNextVk) ignoreNextVk.Clear();
			lock (injectedLock) injectedActive = false;
			kbdHook = 0;
			mouseHook = 0;
		}

		private static bool ShouldDisableHook()
		{
			var env = Environment.GetEnvironmentVariable("KEYSHARP_DISABLE_HOOK");
			return !string.IsNullOrEmpty(env) &&
				   (env.Equals("1") || env.Equals("true", StringComparison.OrdinalIgnoreCase) || env.Equals("yes", StringComparison.OrdinalIgnoreCase));
		}

		// -------------------- event handlers --------------------

		private void OnKeyPressed(object? sender, KeyboardHookEventArgs e)
		{
			if (!keyboardEnabled) return;

			var vk = KeyCodeToVk(e.Data.KeyCode);
			if (vk == 0) return;
			lock (ignoreNextVk)
			{
				if (ignoreNextVk.TryGetValue(vk, out var n) && n > 0)
				{
					ignoreNextVk[vk] = n - 1;
					if (ignoreNextVk[vk] <= 0) ignoreNextVk.Remove(vk);
					DebugLog($"[Hook] KeyDown vk={vk} filtered ignoreNext remaining={ignoreNextVk.GetValueOrDefault(vk)}");
					EndInjectedIgnoreIfIdle();
					return;
				}
			}
			lock (injectedLock)
			{
				if (injectedHeld.ContainsKey(vk))
				{
					DebugLog($"[Hook] KeyDown vk={vk} filtered injectedHold");
					return;
				}
			}
			if (InjectedActive()) { DebugLog($"[Hook] KeyDown vk={vk} filtered injected"); return; }

			long eventLevel = sendInProgress ? sendInProgressLevel : (e.IsEventSimulated ? 0 : PhysicalInputLevel);
			if (eventLevel == 0)
			{
				DebugLog($"[Hook] KeyDown vk={vk} ignored (eventLevel=0)");
				return;
			}

			// Suppress repeat if we still think the key is down physically.
			if (!e.IsEventSimulated && vk < physicalKeyState.Length && (physicalKeyState[vk] & StateDown) != 0)
			{
				DebugLog($"[Hook] KeyDown vk={vk} filtered repeat (phys still down)");
				return;
			}

			// Suppress auto-repeat for an already-active hotkey suffix while the key is held.
			if (activeHotkeyDown && activeHotkeyVk == vk)
			{
				DebugLog($"[Hook] KeyDown vk={vk} filtered (active suffix still down)");
				return;
			}

			var indicatorsBefore = RefreshIndicatorSnapshot();
			var sc = (uint)e.Data.RawCode;
			LogKeyHistory(false, vk, sc);
			DebugLog($"[Hook] KeyDown vk={vk} physMods={CurrentModifiersLR():X} ctrlState={physicalKeyState[Math.Min(VK_CONTROL, (uint)physicalKeyState.Length - 1)]} lctrl={physicalKeyState[Math.Min(VK_LCONTROL, (uint)physicalKeyState.Length - 1)]} rctrl={physicalKeyState[Math.Min(VK_RCONTROL, (uint)physicalKeyState.Length - 1)]} artificial={e.IsEventSimulated}");

			try
			{
				// If a custom prefix is already active, treat this as a suffix attempt.
				if (customPrefix.Vk != 0)
				{
					if (!InjectedActive() && !sendInProgress && vk < physicalKeyState.Length)
					{
						physicalKeyState[vk] = StateDown;
						DebugLog($"[HookState] Down tracked vk={vk} (custom prefix) physMods={CurrentModifiersLR():X}");
					}
					if (vk != customPrefix.Vk)
					{
						// Any other key pressed while the prefix is held should prevent fire-on-release.
						customPrefix.Used = true;
						customPrefix.FireOnRelease = false;
					}
					// When a custom prefix is held, only consider hotkeys that use that prefix.
					TryPostHotkey(vk, keyUp: false, eventLevel, customPrefix.Vk);
					return; // Suppress normal processing while prefix is held.
				}

				// Is this key a custom modifier (prefix)?
				var hkList = linuxHotkeys;
				foreach (var hk in hkList)
				{
					if (hk.ModifierVK == vk)
					{
						customPrefix.Reset();
						customPrefix.Vk = vk;
						customPrefix.Suppressed = customPrefixSuppress.TryGetValue(vk, out var suppress) && suppress;
						customPrefix.Used = false;
						customPrefix.FireOnRelease = customPrefix.Suppressed; // tilde disables fire-on-release
						customPrefix.LockKind = GetLockKind(vk);

						if (customPrefix.Suppressed && customPrefix.LockKind != LockKeyKind.None)
						{
							customPrefix.LockState = customPrefix.LockKind switch
							{
								LockKeyKind.CapsLock => indicatorsBefore.Caps,
								LockKeyKind.NumLock => indicatorsBefore.Num,
								LockKeyKind.ScrollLock => indicatorsBefore.Scroll,
								_ => false
							};
							customPrefix.LockCaptured = true;
						}

						ActivateDynamicGrabsForPrefix(vk, customPrefix.Suppressed);

						if (vk < physicalKeyState.Length)
							physicalKeyState[vk] = StateDown;

						if (customPrefix.Suppressed)
							hsSuppressTypedForHotkeyPrefix = true;
						return; // suppress normal action until resolved
					}
				}

				// Track physical state in physicalKeyState only.
				if (!InjectedActive() && vk < physicalKeyState.Length)
				{
					physicalKeyState[vk] = StateDown;
					logicalKeyState[vk] = true;
					DebugLog($"[HookState] Down tracked vk={vk} physMods={CurrentModifiersLR():X}");
				}

				// Map neutral modifiers to left variants to keep physical state consistent.
				switch (vk)
				{
					case VK_CONTROL:
						if (VK_LCONTROL < physicalKeyState.Length) physicalKeyState[VK_LCONTROL] = StateDown;
						if (VK_RCONTROL < physicalKeyState.Length) physicalKeyState[VK_RCONTROL] = StateDown;
						break;
					case VK_SHIFT:
						if (VK_LSHIFT < physicalKeyState.Length) physicalKeyState[VK_LSHIFT] = StateDown;
						if (VK_RSHIFT < physicalKeyState.Length) physicalKeyState[VK_RSHIFT] = StateDown;
						break;
					case VK_MENU:
						if (VK_LMENU < physicalKeyState.Length) physicalKeyState[VK_LMENU] = StateDown;
						if (VK_RMENU < physicalKeyState.Length) physicalKeyState[VK_RMENU] = StateDown;
						break;
					case VK_LWIN:
					case VK_RWIN:
					case VK_LCONTROL:
					case VK_RCONTROL:
					case VK_LSHIFT:
					case VK_RSHIFT:
					case VK_LMENU:
					case VK_RMENU:
						break;
				}

				// Keep sender modifier masks in sync when the hook is active.
				bool? neutral = null;
				var modLR = KeyToModifiersLR(vk, 0, ref neutral);
				if (modLR != 0)
				{
					kbdMsSender.modifiersLRPhysical |= modLR;
					kbdMsSender.modifiersLRLogical |= modLR;
					kbdMsSender.modifiersLRLogicalNonIgnored |= modLR;
					kbdMsSender.modifiersLRLastPressed = modLR;
					kbdMsSender.modifiersLRLastPressedTime = DateTime.UtcNow;
				}

				// If a terminator is armed and this is one of them, swallow to hotstring:
				if (hsArmed && hsArmedEnds.Count > 0)
				{
					// Choose the best ArmedEnd for this vk based on current modifiers
					ArmedEnd? chosen = null;
					var modsNow = CurrentModifiersLR();

					foreach (var ae in hsArmedEnds)
					{
						if (ae.Vk != vk) continue;

						bool shiftOk = !ae.NeedShift || (modsNow & (MOD_LSHIFT | MOD_RSHIFT)) != 0;
						bool altgrOk = !ae.NeedAltGr || (modsNow & MOD_RALT) != 0; // we treat AltGr as RAlt for LR masks

						if (shiftOk && altgrOk)
						{
							chosen = ae; break;
						}
					}

					if (chosen.HasValue)
					{
						// 1) We matched an armed end key – block it and then release the end key
						Script.TheScript.HookThread.kbdMsSender.SendKeyEvent(KeyEventTypes.KeyUp, vk);

						// 2) Disarm now; the keystroke won’t reach the target app because XGrabKey held it.
						DisarmHotstring();

						var hm = Script.TheScript.HotstringManager;
						lastTypedExtraInfo = eventLevel <= KeyboardMouseSender.SendLevelMax ? (ulong)KeyboardMouseSender.KeyIgnoreLevel(eventLevel) : 0;

						// Append the actual end-char we predicted and verify the match now
						hm.hsBuf.Add(chosen.Value.EndChar);
						LogHotstringBuffer($"armed-end {vk} append '{chosen.Value.EndChar}'");
						var hs = hm.MatchHotstring();

						if (hs != null)
						{
							// Input gating (physical input)
							char? evt = ' ';
							if (KeyboardMouseSender.HotInputLevelAllowsFiring(hs.inputLevel, lastTypedExtraInfo, ref evt))
							{
								// Case conform (same as above)
								var caseMode = ComputeCaseMode(hs, hm.hsBuf);

								_ = channel.Writer.TryWrite(new KeysharpMsg
								{
									message = (uint)UserMessages.AHK_HOTSTRING,
									obj = new HotstringMsg { hs = hs, caseMode = caseMode, endChar = chosen.Value.EndChar }
								});
								LogHotstringBuffer($"hotstring fired '{hs.Name}' end='{chosen.Value.EndChar}'");
								ClearHotstringBuffer("fired");

								// If grabs were lifted during send, the end key may have been delivered; remove it.
								if (sendUngrabActive && chosen.Value.EndChar != '\0')
									kbdMsSender.SendKeyEvent(KeyEventTypes.KeyDownAndUp, VK_BACK);
							}
						}

						// Don’t continue normal hotkey processing for this vk; we deliberately “swallowed” it.
						return;
					}
				}

				// 1) Input listeners
				PostInputKey(UserMessages.AHK_INPUT_KEYDOWN, vk);

				// 2) Hotkeys (down)
				TryPostHotkey(vk, keyUp: false, eventLevel);
			}
			finally
			{
				_ = RefreshIndicatorSnapshot();
			}
		}

		private static readonly uint[] LMods = { VK_LSHIFT, VK_LCONTROL, VK_LMENU, VK_LWIN };
		private static readonly uint[] RMods = { VK_RSHIFT, VK_RCONTROL, VK_RMENU, VK_RWIN };
		internal uint CurrentModifiersLR()
		{
			// Prefer logical (non-ignored) state from the sender when the hook is active
			// and no send is in progress. During Send, the sender may temporarily drop
			// modifiers to emit shifted characters; we should report what is physically
			// held instead so that hotkey suffix checks (e.g. +h) keep seeing Shift.
			if (HasKbdHook())
			{
				if (!sendInProgress)
					return kbdMsSender.modifiersLRLogicalNonIgnored;
				// send in progress: fall through to physical snapshot
			}

			// With no hook, fall back to logical query via X11.
			if (TryQueryModifierLRState(out var logicalMods))
				return logicalMods;

			// Last resort: use physical snapshot.
			uint mods = 0;
			if (VK_LSHIFT < physicalKeyState.Length && (physicalKeyState[VK_LSHIFT] & StateDown) != 0) mods |= MOD_LSHIFT;
			if (VK_RSHIFT < physicalKeyState.Length && (physicalKeyState[VK_RSHIFT] & StateDown) != 0) mods |= MOD_RSHIFT;
			if (VK_LCONTROL < physicalKeyState.Length && (physicalKeyState[VK_LCONTROL] & StateDown) != 0) mods |= MOD_LCONTROL;
			if (VK_RCONTROL < physicalKeyState.Length && (physicalKeyState[VK_RCONTROL] & StateDown) != 0) mods |= MOD_RCONTROL;
			if (VK_LMENU < physicalKeyState.Length && (physicalKeyState[VK_LMENU] & StateDown) != 0) mods |= MOD_LALT;
			if (VK_RMENU < physicalKeyState.Length && (physicalKeyState[VK_RMENU] & StateDown) != 0) mods |= MOD_RALT;
			if (VK_LWIN < physicalKeyState.Length && (physicalKeyState[VK_LWIN] & StateDown) != 0) mods |= MOD_LWIN;
			if (VK_RWIN < physicalKeyState.Length && (physicalKeyState[VK_RWIN] & StateDown) != 0) mods |= MOD_RWIN;
			return mods;
		}

		internal bool TryQueryModifierLRState(out uint mods, byte[]? keymapBuffer = null)
		{
			mods = 0u;

			if (!IsX11Available || xDisplay == IntPtr.Zero)
				return false;

			byte[] keymap = keymapBuffer is { Length: 32 } kb ? kb : new byte[32];

			if (XQueryKeymap(xDisplay, keymap) == 0)
				return false;

			for (int keycode = 8; keycode < 256; keycode++)
			{
				var byteIndex = keycode >> 3;
				var bitMask = 1 << (keycode & 7);

				if ((keymap[byteIndex] & bitMask) == 0)
					continue;

				var keysym = (ulong)XKeycodeToKeysym(xDisplay, keycode, 0);
				if (keysym == 0)
					continue;

				switch (keysym)
				{
					case 0xFFE1: mods |= MOD_LSHIFT; break;     // Shift_L
					case 0xFFE2: mods |= MOD_RSHIFT; break;     // Shift_R
					case 0xFFE3: mods |= MOD_LCONTROL; break; // Control_L
					case 0xFFE4: mods |= MOD_RCONTROL; break; // Control_R
					case 0xFFE9: mods |= MOD_LALT; break;         // Alt_L
					case 0xFFEA: mods |= MOD_RALT; break;         // Alt_R
					case 0xFFEB: mods |= MOD_LWIN; break;         // Super_L
					case 0xFFEC: mods |= MOD_RWIN; break;         // Super_R
				}
			}

			return true;
		}

		private bool TryQueryKeymap(out byte[] keymap)
		{
			keymap = new byte[32];

			if (!IsX11Available || xDisplay == IntPtr.Zero)
				return false;

			return XQueryKeymap(xDisplay, keymap) != 0;
		}

		private bool TryQueryKeyState(uint vk, out bool isDown)
		{
			isDown = false;
			if (!IsX11Available || xDisplay == IntPtr.Zero)
				return false;

			if (!TryQueryKeymap(out var keymap))
				return false;

			// Compute expected keysyms for this vk (primary and alternate, e.g. upper/lower).
			var expected = VkToKeysyms(vk);
			if (expected.Count == 0)
				return false;

			for (int keycode = 8; keycode < 256; keycode++)
			{
				var byteIndex = keycode >> 3;
				var bitMask = 1 << (keycode & 7);
				if ((keymap[byteIndex] & bitMask) == 0)
					continue;

				var keysym = (ulong)XKeycodeToKeysym(xDisplay, keycode, 0);
				if (keysym == 0)
					continue;

				foreach (var ks in expected)
				{
					if ((ulong)ks == keysym)
					{
						isDown = true;
						return true;
					}
				}
			}

			return true; // queried successfully; isDown stays false
		}

		private static List<uint> VkToKeysyms(uint vk)
		{
			var list = new List<uint>(2);

			// Letters: add both lower and upper keysyms
			if (vk is >= (uint)'A' and <= (uint)'Z')
			{
				var upper = vk;
				var lower = vk + 32; // ASCII lowercase
				list.Add(upper);
				list.Add(lower);
				return list;
			}

			// Digits
			if (vk is >= (uint)'0' and <= (uint)'9')
			{
				list.Add(vk);
				return list;
			}

			// Common OEM/punctuation keysyms (US layout assumptions)
			switch (vk)
			{
				case VK_SPACE: list.Add((uint)' '); return list;
				case VK_OEM_MINUS: list.Add((uint)'-'); list.Add((uint)'_'); return list;
				case VK_OEM_PLUS: list.Add((uint)'='); list.Add((uint)'+'); return list;
				case VK_OEM_1: list.Add((uint)';'); list.Add((uint)':'); return list;
				case VK_OEM_2: list.Add((uint)'/'); list.Add((uint)'?'); return list;
				case VK_OEM_3: list.Add((uint)'`'); list.Add((uint)'~'); return list;
				case VK_OEM_4: list.Add((uint)'['); list.Add((uint)'{'); return list;
				case VK_OEM_5: list.Add((uint)'\\'); list.Add((uint)'|'); return list;
				case VK_OEM_6: list.Add((uint)']'); list.Add((uint)'}'); return list;
				case VK_OEM_7: list.Add((uint)'\''); list.Add((uint)'"'); return list;
				case VK_OEM_COMMA: list.Add((uint)','); list.Add((uint)'<'); return list;
				case VK_OEM_PERIOD: list.Add((uint)'.'); list.Add((uint)'>'); return list;
			}

			// Modifiers and special keys: use X11 keysyms
			switch (vk)
			{
				case VK_LSHIFT: list.Add(0xFFE1); break; // Shift_L
				case VK_RSHIFT: list.Add(0xFFE2); break; // Shift_R
				case VK_LCONTROL: list.Add(0xFFE3); break; // Control_L
				case VK_RCONTROL: list.Add(0xFFE4); break; // Control_R
				case VK_LMENU: list.Add(0xFFE9); break; // Alt_L
				case VK_RMENU: list.Add(0xFFEA); break; // Alt_R
				case VK_LWIN: list.Add(0xFFEB); break; // Super_L
				case VK_RWIN: list.Add(0xFFEC); break; // Super_R
				case VK_RETURN: list.Add(0xFF0D); break; // Return
				case VK_TAB: list.Add(0xFF09); break; // Tab
				case VK_ESCAPE: list.Add(0xFF1B); break; // Escape
				case VK_BACK: list.Add(0xFF08); break; // Backspace
				case VK_DELETE: list.Add(0xFFFF); break; // Delete
				case VK_INSERT: list.Add(0xFF63); break; // Insert
				case VK_HOME: list.Add(0xFF50); break;
				case VK_END: list.Add(0xFF57); break;
				case VK_PRIOR: list.Add(0xFF55); break; // PageUp
				case VK_NEXT: list.Add(0xFF56); break;  // PageDown
				case VK_LEFT: list.Add(0xFF51); break;
				case VK_UP: list.Add(0xFF52); break;
				case VK_RIGHT: list.Add(0xFF53); break;
				case VK_DOWN: list.Add(0xFF54); break;
			}

			return list;
		}


		private static uint VkToModMask(uint vk) => vk switch
		{
			VK_LSHIFT => MOD_LSHIFT,
			VK_RSHIFT => MOD_RSHIFT,
			VK_LCONTROL => MOD_LCONTROL,
			VK_RCONTROL => MOD_RCONTROL,
			VK_LMENU => MOD_LALT,
			VK_RMENU => MOD_RALT,
			VK_LWIN => MOD_LWIN,
			VK_RWIN => MOD_RWIN,
			_ => 0u
		};

		internal bool TryGetKeyboardState(out byte[] state)
		{
			state = new byte[VK_ARRAY_COUNT];
			var success = false;

			if (HasKbdHook())
			{
				System.Buffer.BlockCopy(physicalKeyState, 0, state, 0, Math.Min(physicalKeyState.Length, state.Length));
				success = true;
			}
			else if (TryQueryKeymap(out var logicalMap) && TryQueryModifierLRState(out var mods, logicalMap))
			{
				if ((mods & MOD_LSHIFT) != 0 && VK_LSHIFT < state.Length) state[VK_LSHIFT] = StateDown;
				if ((mods & MOD_RSHIFT) != 0 && VK_RSHIFT < state.Length) state[VK_RSHIFT] = StateDown;
				if ((mods & MOD_LCONTROL) != 0 && VK_LCONTROL < state.Length) state[VK_LCONTROL] = StateDown;
				if ((mods & MOD_RCONTROL) != 0 && VK_RCONTROL < state.Length) state[VK_RCONTROL] = StateDown;
				if ((mods & MOD_LALT) != 0 && VK_LMENU < state.Length) state[VK_LMENU] = StateDown;
				if ((mods & MOD_RALT) != 0 && VK_RMENU < state.Length) state[VK_RMENU] = StateDown;
				if ((mods & MOD_LWIN) != 0 && VK_LWIN < state.Length) state[VK_LWIN] = StateDown;
				if ((mods & MOD_RWIN) != 0 && VK_RWIN < state.Length) state[VK_RWIN] = StateDown;
				success = true;
			}

			return success;
		}

		private void OnKeyReleased(object? sender, KeyboardHookEventArgs e)
		{
			if (!keyboardEnabled) return;

			var vk = KeyCodeToVk(e.Data.KeyCode);
			if (vk == 0) return;
			lock (ignoreNextVk)
			{
				if (ignoreNextVk.TryGetValue(vk, out var n) && n > 0)
				{
					ignoreNextVk[vk] = n - 1;
					if (vk == hsIgnoreNextReleaseFor)
						hsIgnoreNextReleaseFor = 0;

					// Do not mutate physical state for synthetic releases; wait for the real one.
					DebugLog($"[Hook] KeyUp vk={vk} filtered ignoreNext remaining={ignoreNextVk.GetValueOrDefault(vk)}");
					EndInjectedIgnoreIfIdle();
					return;
				}
			}
			lock (injectedLock)
			{
				if (injectedHeld.TryGetValue(vk, out var heldCount) && heldCount > 0)
				{
					if (vk == activeHotkeyVk)
					{
						// Allow the active suffix release to flow through while balancing injected count.
						if (heldCount <= 1) injectedHeld.Remove(vk);
						else injectedHeld[vk] = heldCount - 1;
						DebugLog($"[Hook] KeyUp vk={vk} injectedHold (active suffix pass-through)");
					}
					else
					{
						if (heldCount <= 1) injectedHeld.Remove(vk);
						else injectedHeld[vk] = heldCount - 1;
						DebugLog($"[Hook] KeyUp vk={vk} filtered injectedHold");
						return;
					}
				}
			}

			if (vk == hsIgnoreNextReleaseFor)
			{
				hsIgnoreNextReleaseFor = 0;
				if (vk == activeHotkeyVk)
				{
					activeHotkeyDown = false;
					activeHotkeyVk = 0;
				}
				// Don’t feed to Input/hotkeys
				return;
			}

			if (InjectedActive())
			{
				if (vk != activeHotkeyVk)
				{
					DebugLog($"[Hook] KeyUp vk={vk} filtered injected");
					return;
				}

				// Let the active suffix release clear state.
				activeHotkeyDown = false;
				activeHotkeyVk = 0;
			}

			long eventLevel = sendInProgress ? sendInProgressLevel : (e.IsEventSimulated ? 0 : PhysicalInputLevel);
			if (eventLevel == 0)
			{
				DebugLog($"[Hook] KeyUp vk={vk} ignored (eventLevel=0)");

				// Even for simulated/ignored events, ensure custom prefix state is cleared so it
				// doesn't remain active and treat later keys as suffixes.
				if (customPrefix.Vk != 0 && vk == customPrefix.Vk)
				{
					customPrefix.Reset();
					UngrabDynamic();
					hsSuppressTypedForHotkeyPrefix = false;
				}
				return;
			}

			DebugLog($"[Hook] KeyUp vk={vk} physMods={CurrentModifiersLR():X} ctrlState={physicalKeyState[Math.Min(VK_CONTROL, (uint)physicalKeyState.Length - 1)]} lctrl={physicalKeyState[Math.Min(VK_LCONTROL, (uint)physicalKeyState.Length - 1)]} rctrl={physicalKeyState[Math.Min(VK_RCONTROL, (uint)physicalKeyState.Length - 1)]}");
			var sc = (uint)e.Data.RawCode;
			LogKeyHistory(true, vk, sc);

			try
			{
				// If releasing the custom prefix, decide whether to emit its normal action.
				if (customPrefix.Vk != 0 && vk == customPrefix.Vk)
				{
					// Fire the prefix hotkey on release if allowed and no other key was pressed.
					if (customPrefix.FireOnRelease && !customPrefix.Used)
					{
						TryPostHotkey(vk, keyUp: false, PhysicalInputLevel);
						TryPostHotkey(vk, keyUp: true, PhysicalInputLevel);
					}

					RestoreLockStateIfNeeded(vk);
					if (vk < physicalKeyState.Length)
						physicalKeyState[vk] = 0;
					switch (vk)
					{
						case VK_CONTROL:
							if (VK_LCONTROL < physicalKeyState.Length) physicalKeyState[VK_LCONTROL] = 0;
							if (VK_RCONTROL < physicalKeyState.Length) physicalKeyState[VK_RCONTROL] = 0;
							break;
						case VK_SHIFT:
							if (VK_LSHIFT < physicalKeyState.Length) physicalKeyState[VK_LSHIFT] = 0;
							if (VK_RSHIFT < physicalKeyState.Length) physicalKeyState[VK_RSHIFT] = 0;
							break;
						case VK_MENU:
							if (VK_LMENU < physicalKeyState.Length) physicalKeyState[VK_LMENU] = 0;
							if (VK_RMENU < physicalKeyState.Length) physicalKeyState[VK_RMENU] = 0;
							break;
					}
					customPrefix.Reset();
					UngrabDynamic();
					hsSuppressTypedForHotkeyPrefix = false;
					return;
				}

				// If a custom prefix is held, treat this as a suffix release and ignore unrelated hotkeys.
				if (customPrefix.Vk != 0)
				{
					if (!InjectedActive() && vk < physicalKeyState.Length)
					{
						physicalKeyState[vk] = 0;
						logicalKeyState[vk] = false;
						DebugLog($"[HookState] Up tracked vk={vk} (custom prefix) physMods={CurrentModifiersLR():X}");
					}
					if (vk != customPrefix.Vk)
					{
						customPrefix.Used = true;
						customPrefix.FireOnRelease = false;
					}
					TryPostHotkey(vk, keyUp: true, eventLevel, customPrefix.Vk);
					return;
				}

				if (!InjectedActive() && vk < physicalKeyState.Length)
				{
					physicalKeyState[vk] = 0;
					logicalKeyState[vk] = false;
					DebugLog($"[HookState] Up tracked vk={vk} physMods={CurrentModifiersLR():X}");
				}
				switch (vk)
				{
					case VK_CONTROL:
						if (VK_LCONTROL < physicalKeyState.Length) physicalKeyState[VK_LCONTROL] = 0;
						if (VK_RCONTROL < physicalKeyState.Length) physicalKeyState[VK_RCONTROL] = 0;
						break;
					case VK_SHIFT:
						if (VK_LSHIFT < physicalKeyState.Length) physicalKeyState[VK_LSHIFT] = 0;
						if (VK_RSHIFT < physicalKeyState.Length) physicalKeyState[VK_RSHIFT] = 0;
						break;
					case VK_MENU:
						if (VK_LMENU < physicalKeyState.Length) physicalKeyState[VK_LMENU] = 0;
						if (VK_RMENU < physicalKeyState.Length) physicalKeyState[VK_RMENU] = 0;
						break;
				}

				bool? neutral = null;
				var modUp = KeyToModifiersLR(vk, 0, ref neutral);
				if (modUp != 0)
				{
					kbdMsSender.modifiersLRPhysical &= ~modUp;
					kbdMsSender.modifiersLRLogical &= ~modUp;
					kbdMsSender.modifiersLRLogicalNonIgnored &= ~modUp;
				}

				// 1) Input listeners
				PostInputKey(UserMessages.AHK_INPUT_KEYUP, vk);

				// 2) Hotkeys (up)
				TryPostHotkey(vk, keyUp: true, eventLevel);
			}
			finally
			{
				_ = RefreshIndicatorSnapshot();

				// If this was the active hotkey suffix, allow re-triggering on next press.
				if (vk == activeHotkeyVk)
					activeHotkeyDown = false;
			}
		}

		private void OnKeyTyped(object? sender, KeyboardHookEventArgs e)
		{
			if (!keyboardEnabled) return;
			if (hsSuppressTypedForEnd) { hsSuppressTypedForEnd = false; return; }
			if (hsSuppressTypedForHotkeyPrefix) return;
			if (hsSuppressTypedForHotkeyOnce) { hsSuppressTypedForHotkeyOnce = false; return; }
			if (InjectedActive()) return;
			if (activeHotkeyDown && activeHotkeyVk != 0) return;

			var ch = e.Data.KeyChar;
			if (ch == '\0') return;

			long eventLevel = sendInProgress ? sendInProgressLevel : (e.IsEventSimulated ? 0 : PhysicalInputLevel);
			if (eventLevel == 0)
			{
				DebugLog($"[Hook] KeyTyped ignored level=0 ch={ch}");
				return;
			}

			// Forward to Input hooks so hotstrings stay fed; main thread does replacement. :contentReference[oaicite:13]{index=13}
			_ = channel.Writer.TryWrite(new KeysharpMsg
			{
				message = (uint)UserMessages.AHK_INPUT_CHAR,
				obj = Script.TheScript.input, // consumed in reader by matching exact instance
				lParam = new IntPtr(ch),
				wParam = IntPtr.Zero
			});


			// Keep HS buffer in sync (like Windows)
			var hm = Script.TheScript.HotstringManager;
			var chDesc = ch switch { '\n' => "\\n", '\r' => "\\r", '\t' => "\\t", _ when char.IsControl(ch) => "\\u" + ((int)ch).ToString("X4"), _ => ch.ToString() };
			lastTypedExtraInfo = eventLevel <= KeyboardMouseSender.SendLevelMax ? (ulong)KeyboardMouseSender.KeyIgnoreLevel(eventLevel) : 0;

			// Backspace should delete from the buffer rather than insert the control char.
			if (ch == '\b')
			{
				if (hm.hsBuf.Count > 0)
				{
					hm.hsBuf.RemoveAt(hm.hsBuf.Count - 1);
					LogHotstringBuffer("backspace");
				}
				RecomputeHotstringArming();
				return;
			}

			hm.hsBuf.Add(ch);
			LogHotstringBuffer($"typed '{chDesc}'");

			// Recompute prediction & arm needed end-keys (all that would complete a match)
			RecomputeHotstringArming();
		}

		private void OnMouseWheel(object? sender, MouseWheelHookEventArgs e)
		{
			if (!mouseEnabled) return;
			var vk = MapWheelVk(e);
			if (vk != 0)
				TryPostHotkey(vk, keyUp: false, PhysicalInputLevel);
		}

		private void OnMousePressed(object? sender, MouseHookEventArgs e)
		{
			if (!mouseEnabled) return;

			var vk = MapMouseVk(e.Data.Button);
			if (vk != 0 && vk < physicalKeyState.Length)
				physicalKeyState[vk] = StateDown;

			// Mouse clicks should reset hotstring buffer (Windows parity) unless #Hotstring NoMouse is in effect.
			var hm = Script.TheScript.HotstringManager;
			if (hm.hsResetUponMouseClick && (vk == VK_LBUTTON || vk == VK_RBUTTON))
			{
				ClearHotstringBuffer($"mouse reset vk={vk}");
				DisarmHotstring();
			}

			if (vk != 0)
				TryPostHotkey(vk, keyUp: false, PhysicalInputLevel);
		}

		private void OnMouseReleased(object? sender, MouseHookEventArgs e)
		{
			if (!mouseEnabled) return;

			var vk = MapMouseVk(e.Data.Button);
			if (vk != 0 && vk < physicalKeyState.Length)
				physicalKeyState[vk] = 0;

			if (vk != 0)
				TryPostHotkey(vk, keyUp: true, PhysicalInputLevel);
		}

		private static uint MapMouseVk(MouseButton button) => button switch
		{
			MouseButton.Button1 => VK_LBUTTON,
			MouseButton.Button2 => VK_RBUTTON,
			MouseButton.Button3 => VK_MBUTTON,
			MouseButton.Button4 => VK_XBUTTON1,
			MouseButton.Button5 => VK_XBUTTON2,
			_ => 0u
		};

		private static uint MapWheelVk(MouseWheelHookEventArgs e)
		{
			if (e.Data.Direction == MouseWheelScrollDirection.Vertical)
				return e.Data.Rotation < 0 ? VK_WHEEL_UP : VK_WHEEL_DOWN;
			return e.Data.Rotation < 0 ? VK_WHEEL_LEFT : VK_WHEEL_RIGHT;
		}

		// Cancel any active keyboard grab that might be in effect due to a passive XGrabKey match.
		internal void CancelActiveKeyboardGrab()
		{
			if (xDisplay == IntPtr.Zero) return;
			try
			{
				_ = XUngrabKeyboard(xDisplay, CurrentTime);
				_ = XSync(xDisplay, false);
				_ = XFlush(xDisplay);
			}
			catch { /* best-effort */ }
		}

		// Temporarily release all grabs (keyboard + passive keys) during a send, then re-apply them.
		internal GrabSnapshot BeginSendUngrab()
		{
			DebugLog("[Hook] BeginSendUngrab");
			var snap = new GrabSnapshot { Active = xDisplay != IntPtr.Zero && xRoot != IntPtr.Zero };
			if (!snap.Active)
			{
				DebugLog("[Hook] BeginSendUngrab skipped (no xDisplay/xRoot)");
				return snap;
			}

			snap.Grabs = new List<(int keycode, uint mods)>(activeGrabs);
			snap.DynamicGrabs = new List<(int keycode, uint mods)>(activeDynamicGrabs);

			try
			{
				foreach (var (kc, mods) in snap.Grabs)
					_ = XUngrabKey(xDisplay, kc, mods, xRoot);
				foreach (var (kc, mods) in snap.DynamicGrabs)
					_ = XUngrabKey(xDisplay, kc, mods, xRoot);

				_ = XUngrabKeyboard(xDisplay, CurrentTime);
				_ = XSync(xDisplay, false);
				_ = XFlush(xDisplay);
			}
			catch { /* best-effort */ }

			return snap;
		}

		internal void EndSendUngrab(GrabSnapshot snap)
		{
			if (!snap.Active || xDisplay == IntPtr.Zero || xRoot == IntPtr.Zero)
				return;

			try
			{
				foreach (var (kc, mods) in snap.Grabs)
					_ = XGrabKey(xDisplay, kc, mods, xRoot, true, GrabModeAsync, GrabModeAsync);
				foreach (var (kc, mods) in snap.DynamicGrabs)
					_ = XGrabKey(xDisplay, kc, mods, xRoot, true, GrabModeAsync, GrabModeAsync);

				_ = XSync(xDisplay, false);
				_ = XFlush(xDisplay);
			}
			catch { /* best-effort */ }
			DebugLog("[Hook] EndSendUngrab");
		}

		private void DisarmHotstring()
		{
			if (!hsArmed)
				return;

			if (xDisplay != IntPtr.Zero && xRoot != IntPtr.Zero)
			{
				foreach (var (kc, mods) in hsActiveGrabVariants)
					_ = XUngrabKey(xDisplay, kc, mods, xRoot);

				hsActiveGrabVariants.Clear();
				_ = XUngrabKeyboard(xDisplay, CurrentTime);
				_ = XSync(xDisplay, false);
			}

			hsArmedEnds.Clear();
			hsArmed = false;
			hsIgnoreNextReleaseFor = 0;
			hsSuppressTypedForEnd = false;
		}

		// Arm a set of end characters (all that would complete a match NOW)
		private void ArmHotstringForEnds(HashSet<char> endsToArm)
		{
			DisarmHotstring();
			if (endsToArm.Count == 0 || !IsX11Available)
				return;

			foreach (var endChar in endsToArm)
			{
				if (!MapEndCharToVkAndNeeds(endChar, out var vk, out var needShift, out var needAltGr))
					continue;

				var ks = VkToKeysym(vk);
				if (ks == 0)
					continue;

				int keycode = XKeysymToKeycode(xDisplay, (IntPtr)ks);
				if (keycode == 0)
					continue;

				uint baseMods = 0;
				if (needShift) baseMods |= ShiftMask;
				if (needAltGr) baseMods |= Mod5Mask; // AltGr

				// Grab with CapsLock/NumLock variants like elsewhere.
				// Grab with the base mods plus Caps/NumLock variants. Allow Shift as an extra
				// modifier even when it isn't required so that shifted end-keys (e.g. holding
				// Shift while pressing Space) still get swallowed and don't leak through to
				// the target app when firing uppercase hotstrings.
				var modsToGrab = new HashSet<uint>
				{
					baseMods,
					baseMods | LockMask,
					baseMods | Mod2Mask,
					baseMods | LockMask | Mod2Mask
				};

				if (!needShift)
				{
					modsToGrab.Add(baseMods | ShiftMask);
					modsToGrab.Add(baseMods | ShiftMask | LockMask);
					modsToGrab.Add(baseMods | ShiftMask | Mod2Mask);
					modsToGrab.Add(baseMods | ShiftMask | LockMask | Mod2Mask);
				}

				foreach (var mods in modsToGrab)
				{
					_ = XGrabKey(xDisplay, keycode, mods, xRoot, true, GrabModeAsync, GrabModeAsync);
					hsActiveGrabVariants.Add((keycode, mods));
				}

				hsArmedEnds.Add(new ArmedEnd
				{
					Keycode = keycode,
					XModsBase = baseMods,
					Vk = vk,
					EndChar = endChar,
					NeedShift = needShift,
					NeedAltGr = needAltGr
				});
			}

			if (hsActiveGrabVariants.Count > 0)
			{
				XSync(xDisplay, false);
				hsArmed = true;
			}
		}

		// After we mutate the hs buffer, call this to (re)compute arming
		private void RecomputeHotstringArming()
		{
			var script = Script.TheScript;
			var hm = script.HotstringManager;

			// 1) If a full match exists already (e.g., non-terminating HS), trigger immediately.
			var ready = hm.MatchHotstring();
			if (ready != null)
			{
				char? evtChar = ' ';
				if (!KeyboardMouseSender.HotInputLevelAllowsFiring(ready.inputLevel, lastTypedExtraInfo, ref evtChar))
				{
					LogHotstringBuffer($"match gated by inputlevel={ready.inputLevel} lastExtra={lastTypedExtraInfo}");
					DisarmHotstring();
					return;
				}

				// Determine case + end char like Windows (same code you already use below)
				var caseMode = ComputeCaseMode(ready, hm.hsBuf);

				char endChar = '\0';
				var sspan = System.Runtime.InteropServices.CollectionsMarshal.AsSpan(hm.hsBuf);
				if (ready.endCharRequired && sspan.Length > 0)
					endChar = sspan[^1];

				_ = channel.Writer.TryWrite(new KeysharpMsg
				{
					message = (uint)UserMessages.AHK_HOTSTRING,
					obj = new HotstringMsg { hs = ready, caseMode = caseMode, endChar = endChar }
				});
				LogHotstringBuffer($"hotstring fired '{ready.Name}' end='{(endChar == '\0' ? "\\0" : endChar.ToString())}'");
				ClearHotstringBuffer("fired");

				DisarmHotstring();
				return;
			}

			// 2) Predict: append each possible end-char; if MatchHotstring() would succeed, arm that end-char.
			var ends = new HashSet<char>();

			// Prefer manager’s configured defaults; fall back to a sensible superset if needed.
			var def = hm.defEndChars ?? string.Empty;
			foreach (var c in def)
			{
				hm.hsBuf.Add(c);
				var m = hm.MatchHotstring();
				hm.hsBuf.RemoveAt(hm.hsBuf.Count - 1);
				if (m != null)
					ends.Add(c);
			}

			// If manager had no defaults or nothing matched, you can optionally include extra common terminators:
			// foreach (var c in " \t\r\n.,;:!?-") { ... }  // (uncomment if you want a bit more aggressive prediction)

			// Arm (or disarm) accordingly
			if (ends.Count > 0) ArmHotstringForEnds(ends);
			else DisarmHotstring();
		}

		internal void ForceReleaseEndKeyX11(uint vk)
		{
			if (!IsX11Available) return;

			ulong ks = VkToKeysym(vk);
			if (ks == 0) return;

			int keycode = XKeysymToKeycode(xDisplay, (IntPtr)ks);
			if (keycode == 0) return;

			// Send a synthetic KeyRelease now, so the target won’t think the key is held
			_ = XTestFakeKeyEvent(xDisplay, keycode, is_press: false, delay: 0);
			_ = XFlush(xDisplay);

			// Update our local state and ignore the real release we’ll get shortly
			if (vk < physicalKeyState.Length)
				physicalKeyState[vk] = 0;
		}

		// Map a candidate end character to VK + required modifiers (layout-aware)
		private bool MapEndCharToVkAndNeeds(char endChar, out uint vk, out bool needShift, out bool needAltGr)
		{
			vk = 0; needShift = needAltGr = false;

			switch (endChar)
			{
				case ' ': vk = VK_SPACE; return true;
				case '\t': vk = VK_TAB; return true;
				case '\r':
				case '\n': vk = VK_RETURN; return true;
			}

			// Use the same mapper you use for Send (handles punctuation layout properly)
			if (System.Text.Rune.TryGetRuneAt(endChar.ToString(), 0, out var rune)
				&& LinuxKeyboardMouseSender.LinuxCharMapper.TryMapRuneToKeystroke(rune, out var mappedVk, out var s, out var g))
			{
				vk = mappedVk; needShift = s; needAltGr = g;
				return vk != 0;
			}
			return false;
		}

		private void PostInputKey(UserMessages kind, uint vk)
		{
			for (var input = Script.TheScript.input; input != null; input = input.prev)
			{
				if (!input.InProgress()) continue;

				_ = channel.Writer.TryWrite(new KeysharpMsg
				{
					message = (uint)kind,
					obj = input,
					lParam = new IntPtr((long)vk),
					wParam = IntPtr.Zero
				});
			}
		}

		private void LogKeyHistory(bool keyUp, uint vk, uint sc = 0)
		{
			var kh = keyHistory;
			if (kh == null || kh.Size == 0 || vk == 0)
				return;

			var item = kh.NextItem();
			item.keyUp = keyUp;
			item.vk = vk;
			item.sc = sc;
			item.eventType = ' ';

			var win = Script.TheScript.WindowProvider.Manager.ActiveWindow;
			var forewin = win.Handle;
			item.targetWindow = forewin != 0
				? (forewin != kh.HistoryHwndPrev ? win.Title : "")
				: "N/A";
			kh.HistoryHwndPrev = forewin;
		}

		private static LockKeyKind GetLockKind(uint vk) => vk switch
		{
			VK_CAPITAL => LockKeyKind.CapsLock,
			VK_NUMLOCK => LockKeyKind.NumLock,
			VK_SCROLL => LockKeyKind.ScrollLock,
			_ => LockKeyKind.None
		};

		private void ActivateDynamicGrabsForPrefix(uint vk, bool suppressed)
		{
			if (!suppressed)
				return;

			if (!dynamicPrefixGrabs.TryGetValue(vk, out var list) || list.Count == 0)
				return;

			UngrabDynamic(); // clear any stale grabs

			foreach (var (kc, mods) in list)
			{
				// If the same grab is already active (due to a normal hotkey on that suffix),
				// don't duplicate it here; otherwise UngrabDynamic would remove it.
				bool alreadyGrabbed = false;
				foreach (var (gkc, gmods) in activeGrabs)
				{
					if (gkc == kc && gmods == mods) { alreadyGrabbed = true; break; }
				}
				if (alreadyGrabbed)
					continue;

				GrabKeyVariantsInto(kc, mods, activeDynamicGrabs);
			}
		}

		private void RestoreLockStateIfNeeded(uint vk)
		{
			if (!customPrefix.Suppressed || customPrefix.LockKind == LockKeyKind.None || !customPrefix.LockCaptured)
				return;

			if (!TryGetIndicatorStates(out var capsOn, out var numOn, out var scrollOn))
				return;

			var current = customPrefix.LockKind switch
			{
				LockKeyKind.CapsLock => capsOn,
				LockKeyKind.NumLock => numOn,
				LockKeyKind.ScrollLock => scrollOn,
				_ => false
			};

			if (current != customPrefix.LockState)
				kbdMsSender.SendKeyEvent(KeyEventTypes.KeyDownAndUp, vk);
		}

		private IndicatorSnapshot RefreshIndicatorSnapshot()
		{
			if (TryGetIndicatorStates(out var capsOn, out var numOn, out var scrollOn))
			{
				indicatorSnapshot = new IndicatorSnapshot(capsOn, numOn, scrollOn);
				return indicatorSnapshot;
			}

			return indicatorSnapshot;
		}

		// -------------------- basic matcher → AHK_HOOK_HOTKEY --------------------
		private static short PhysicalInputLevel => (short)(Keysharp.Core.Common.Keyboard.KeyboardMouseSender.SendLevelMax + 1);
		private void TryPostHotkey(uint vk, bool keyUp, long eventLevel, uint? requiredModifierVk = null)
		{
			uint? idWithFlags = null;
			bool passThrough = true;

			lock (hkLock)
			{
				if (linuxHotkeys.Count == 0)
					return;

				var currentLR = GetCurrentModifiersLRExcludingSuffix(vk);
				var currentNeutral = ConvertModifiersLR(currentLR); // to MOD_SHIFT/MOD_CONTROL/MOD_ALT/MOD_WIN
				DebugLog($"[Hook] TryPostHotkey vk={vk} keyUp={keyUp} currentLR={currentLR:X} neutral={currentNeutral:X}");

				// naive linear scan (list is typically small)
				foreach (var hk in linuxHotkeys)
				{
					if (hk.Vk != vk) continue;
					if (hk.KeyUp != keyUp) continue;
					if (requiredModifierVk.HasValue && hk.ModifierVK != requiredModifierVk.Value) continue;

					if (hk.ModifierVK != 0)
					{
						if (hk.ModifierVK >= physicalKeyState.Length || (physicalKeyState[hk.ModifierVK] & StateDown) == 0)
							continue;
					}

					var hkNeutral = ConvertModifiersLR(hk.ModifiersLR);
					bool modsMatch;
					if (hk.AllowExtra)
					{
						var hasAllRequired = (currentNeutral & hkNeutral) == hkNeutral;
						if (hk.KeyUp && hkNeutral != 0 && !hasAllRequired)
						{
							// For wildcard (*) key-up hotkeys, only allow missing modifiers if this suffix was active.
							var allowMissing = activeHotkeyDown && activeHotkeyVk == vk;
							modsMatch = allowMissing && (currentNeutral & hkNeutral) == currentNeutral;
						}
						else
							modsMatch = hasAllRequired;
					}
					else
						modsMatch = currentNeutral == hkNeutral; // non-wildcard: exact match

					if (modsMatch)
					{
						idWithFlags = hk.IdWithFlags;
						passThrough = hk.PassThrough;
						break;
					}
				}
			}

			if (!idWithFlags.HasValue)
				return;

			if (sendInProgress)
				return;

			if (InjectedActive() && !(keyUp && vk == activeHotkeyVk))
			{
				DebugLog($"[Hook] TryPostHotkey vk={vk} skipped (injected active)");
				return;
			}

			// Suppress auto-repeat re-entry for the same suffix until its real KeyUp.
			if (!keyUp && activeHotkeyDown && activeHotkeyVk == vk)
				return;
			DebugLog($"[DbgHot] PostHotkey vk={vk} keyUp={keyUp} actVk={activeHotkeyVk} actDown={activeHotkeyDown}");

			if (!keyUp)
			{
				activeHotkeyDown = true;
				activeHotkeyVk = vk;
				// Reflect hotkey handling in logical state: suffix is blocked from the target app.
				if (!passThrough && vk < logicalKeyState.Length)
					logicalKeyState[vk] = false;
			}
			else if (vk == activeHotkeyVk)
			{
				activeHotkeyDown = false;
			}

			PostHotkey(idWithFlags.Value, 0, eventLevel);

			// If the hotkey is suppressing its suffix, prevent the corresponding KeyTyped from feeding hotstrings.
			if (!passThrough && !keyUp && !IsMouseVK(vk))
				hsSuppressTypedForHotkeyOnce = true;
		}

		internal bool HasKeyUpHotkey(uint vk)
		{
			lock (hkLock)
			{
				foreach (var hk in linuxHotkeys)
				{
					if (hk.Vk == vk && hk.KeyUp)
						return true;
				}
			}
			return false;
		}

		internal void BeginSend(long sendLevel)
		{
			DebugLog("[Hook] BeginSend");
			sendInProgressLevel = sendLevel;
			sendInProgress = true;
		}

		internal void EndSend()
		{
			DebugLog("[Hook] EndSend");
			sendInProgress = false;
			sendInProgressLevel = 0;
			lock (injectedLock)
			{
				injectedHeld.Clear();
				injectedActive = false;
			}
			EndInjectedIgnoreIfIdle();
		}

		internal void BeginInjectedIgnore()
		{
			lock (injectedLock)
			{
				injectedActive = true;
				DebugLog("[Hook] BeginInjectedIgnore");
			}
		}

		internal void EndInjectedIgnore()
		{
			EndInjectedIgnoreIfIdle();
		}

		internal void MarkModifiersDown(uint mods)
		{
			// Keep sender masks in sync so CurrentModifiersLR() reflects the restored state.
			kbdMsSender.modifiersLRPhysical = mods;
			kbdMsSender.modifiersLRLogical = mods;
			kbdMsSender.modifiersLRLogicalNonIgnored = mods;

			void SetDown(uint vk)
			{
				if (vk >= physicalKeyState.Length) return;
				physicalKeyState[vk] = StateDown;
				if (vk < logicalKeyState.Length) logicalKeyState[vk] = true;
			}

			if ((mods & MOD_LSHIFT) != 0) SetDown(VK_LSHIFT);
			if ((mods & MOD_RSHIFT) != 0) SetDown(VK_RSHIFT);
			if ((mods & MOD_LCONTROL) != 0) SetDown(VK_LCONTROL);
			if ((mods & MOD_RCONTROL) != 0) SetDown(VK_RCONTROL);
			if ((mods & MOD_LALT) != 0) SetDown(VK_LMENU);
			if ((mods & MOD_RALT) != 0) SetDown(VK_RMENU);
			if ((mods & MOD_LWIN) != 0) SetDown(VK_LWIN);
			if ((mods & MOD_RWIN) != 0) SetDown(VK_RWIN);
		}

		internal void ClearIgnoreNext()
		{
			lock (ignoreNextVk)
				ignoreNextVk.Clear();
		}

		internal void ResetActiveHotkeyState()
		{
			activeHotkeyDown = false;
			activeHotkeyVk = 0;
		}

		internal void TrackInjectedHold(uint vk, bool down)
		{
			if (vk == 0) return;
			lock (injectedLock)
			{
				if (down)
				{
					injectedHeld.TryGetValue(vk, out var curr);
					injectedHeld[vk] = curr + 1;
				}
				else
				{
					if (injectedHeld.TryGetValue(vk, out var curr))
					{
						if (curr <= 1) injectedHeld.Remove(vk);
						else injectedHeld[vk] = curr - 1;
					}
				}
			}
		}

		private void EndInjectedIgnoreIfIdle()
		{
			lock (injectedLock)
			{
				if (!injectedActive)
					return;

				// Keep ignore mode active while sending or while injected key holds remain.
				if (sendInProgress)
					return;

				lock (ignoreNextVk)
				{
					foreach (var kv in ignoreNextVk)
					{
						if (kv.Value > 0)
							return;
					}
				}

				if (injectedHeld.Count > 0)
					return;

				injectedActive = false;
				DebugLog("[Hook] EndInjectedIgnore");
			}
		}

		private bool InjectedActive()
		{
			lock (injectedLock)
			{
				return injectedActive;
			}
		}

		private void PostHotkey(uint hotkeyId, uint sc /* typically 0 on Linux */, long eventLevel)
		{
			// Mirror Windows: pack SC (low word) + event input level (high word), variant omitted.
			_ = channel.Writer.TryWrite(new KeysharpMsg
			{
				message = (uint)UserMessages.AHK_HOOK_HOTKEY,
				wParam = new nint(hotkeyId),
				lParam = new nint(KeyboardUtils.MakeLong((short)sc, (short)eventLevel)),
				obj = null // <— Do NOT pass variant; UI thread recomputes it.
			});
		}

		private uint GetCurrentModifiersLRExcludingSuffix(uint suffixVk)
		{
			uint mods = 0;

			// Consider *physical* state at the time of event.
			for (uint vk = 0; vk < VK_ARRAY_COUNT; vk++)
			{
				if (vk == suffixVk) continue; // a suffix doesn't modify itself (Windows does similar) :contentReference[oaicite:17]{index=17}
				if (vk >= physicalKeyState.Length) break;
				if ((physicalKeyState[vk] & StateDown) == 0) continue;

				switch (vk)
				{
					case VK_LSHIFT: mods |= MOD_LSHIFT; break;
					case VK_RSHIFT: mods |= MOD_RSHIFT; break;
					case VK_LCONTROL: mods |= MOD_LCONTROL; break;
					case VK_RCONTROL: mods |= MOD_RCONTROL; break;
					case VK_LMENU: mods |= MOD_LALT; break;
					case VK_RMENU: mods |= MOD_RALT; break;
					case VK_LWIN: mods |= MOD_LWIN; break;
					case VK_RWIN: mods |= MOD_RWIN; break;
				}
			}
			return mods;
		}

		// -------------------- utilities & abstract impls --------------------

		internal override bool IsKeyDown(uint vk)
		{
			if (HasKbdHook() && vk < logicalKeyState.Length)
				return logicalKeyState[vk];

			// Fallback: query X11 logical state for any key.
			if (TryQueryKeyState(vk, out var isDown))
				return isDown;

			return false;
		}
		internal override bool IsKeyDownAsync(uint vk) => IsKeyDown(vk);
		internal override bool IsKeyToggledOn(uint vk)
		{
			if (TryGetIndicatorStates(out var capsOn, out var numOn, out var scrollOn))
			{
				return vk switch
				{
					VK_CAPITAL => capsOn,
					VK_NUMLOCK => numOn,
					VK_SCROLL => scrollOn,
					_ => false
				};
			}

			return false;
		}

		internal override bool IsMouseVK(uint vk)
			=> vk == VK_LBUTTON || vk == VK_RBUTTON || vk == VK_MBUTTON || vk == VK_XBUTTON1 || vk == VK_XBUTTON2;

		internal override bool IsWheelVK(uint vk)
			=> vk == VK_WHEEL_UP || vk == VK_WHEEL_DOWN || vk == VK_WHEEL_LEFT || vk == VK_WHEEL_RIGHT;

		internal void IgnoreNext(uint vk, int count)
		{
			if (vk == 0 || count <= 0) return;
			lock (ignoreNextVk)
			{
				ignoreNextVk.TryGetValue(vk, out var curr);
				ignoreNextVk[vk] = curr + count;
				DebugLog($"[Hook] Ignoring next {count} events for vk={vk} (total now {ignoreNextVk[vk]})");
			}
		}

		internal override uint KeyToModifiersLR(uint vk, uint sc, ref bool? isNeutral)
			=> vk switch
			{
				VK_LSHIFT => MOD_LSHIFT,
				VK_RSHIFT => MOD_RSHIFT,
				VK_LCONTROL => MOD_LCONTROL,
				VK_RCONTROL => MOD_RCONTROL,
				VK_LMENU => MOD_LALT,
				VK_RMENU => MOD_RALT,
				VK_LWIN => MOD_LWIN,
				VK_RWIN => MOD_RWIN,
				_ => 0
			};

		internal override uint MapScToVk(uint sc)
		{
			if (!IsX11Available || xDisplay == IntPtr.Zero || sc == 0)
				return 0;

			var ks = (ulong)XKeycodeToKeysym(xDisplay, (int)sc, 0);
			return ks != 0 ? VkFromKeysym(ks) : 0;
		}

		internal override uint MapVkToSc(uint vk, bool returnSecondary = false)
		{
			if (!IsX11Available || xDisplay == IntPtr.Zero || vk == 0)
				return 0;

			ulong ks = VkToKeysym(vk);
			if (ks == 0) return 0;

			return (uint)XKeysymToKeycode(xDisplay, (IntPtr)ks);
		}

		internal override bool EarlyCollectInput(ulong extraInfo, uint vk, uint sc, bool keyUp, bool isIgnored
										, CollectInputState state, KeyHistoryItem keyHistoryCurr) => throw new NotImplementedException();

		internal override uint CharToVKAndModifiers(char ch, ref uint? modifiersLr, nint keybdLayout, bool enableAZFallback = false)
		{
			// Delegate to the Linux char mapper used by the sender; add Shift/AltGr if needed.
			if (Rune.TryGetRuneAt(ch.ToString(), 0, out var rune)
				&& LinuxKeyboardMouseSender.LinuxCharMapper.TryMapRuneToKeystroke(rune, out var vk, out var needShift, out var needAltGr))
			{
				uint mods = modifiersLr ?? 0;
				if (needShift) mods |= MOD_LSHIFT;
				if (needAltGr) mods |= MOD_RALT;
				modifiersLr = mods;
				return vk;
			}
			return 0;
		}

		internal override bool SystemHasAnotherKeybdHook() => false;
		internal override bool SystemHasAnotherMouseHook() => false;

		private void ClearHotstringBuffer(string reason)
		{
			var hm = Script.TheScript.HotstringManager;
			if (hm.hsBuf.Count == 0)
			{
				LogHotstringBuffer(reason);
				return;
			}

			hm.hsBuf.Clear();
			LogHotstringBuffer(reason);
		}

		private void LogHotstringBuffer(string reason)
		{
			var hm = Script.TheScript.HotstringManager;
			var sb = new StringBuilder(hm.hsBuf.Count * 2);

			static string EscapeChar(char c) => c switch
			{
				'\n' => "\\n",
				'\r' => "\\r",
				'\t' => "\\t",
				_ when char.IsControl(c) => "\\u" + ((int)c).ToString("X4"),
				_ => c.ToString()
			};

			foreach (var ch in hm.hsBuf)
				sb.Append(EscapeChar(ch));

			DebugLog($"[HS] {reason}: len={hm.hsBuf.Count} buf=\"{sb}\" armed={hsArmed}");
		}

		// -------------------- X11 (blocking) --------------------

		private bool TryMapToXGrab(uint vk, uint modifiersLR, out int keycode, out uint mods)
		{
			keycode = 0; mods = 0;
			if (!IsX11Available) return false;

			// VK -> KeySym -> keycode
			ulong ks = VkToKeysym(vk);
			if (ks == 0) return false;

			keycode = XKeysymToKeycode(xDisplay, (IntPtr)ks);
			if (keycode == 0) return false;

			// LR modifiers → X11 masks
			if ((modifiersLR & (MOD_LCONTROL | MOD_RCONTROL)) != 0) mods |= ControlMask;
			if ((modifiersLR & (MOD_LSHIFT | MOD_RSHIFT)) != 0) mods |= ShiftMask;
			if ((modifiersLR & (MOD_LALT | MOD_RALT)) != 0) mods |= Mod1Mask; // Alt
			if ((modifiersLR & (MOD_LWIN | MOD_RWIN)) != 0) mods |= Mod4Mask; // Super

			return true;
		}

		private void GrabKey(int keycode, uint modifiers)
		{
			GrabKeyVariantsInto(keycode, modifiers, activeGrabs);
		}

		private void GrabKeyVariantsInto(int keycode, uint modifiers, List<(int keycode, uint mods)> sink, bool anyModifier = false)
		{
			if (!IsX11Available) return;

			uint[] variants = anyModifier
				? new[] { AnyModifier }
				: new[]
				{
					modifiers,
					modifiers | LockMask,
					modifiers | Mod2Mask,
					modifiers | LockMask | Mod2Mask
				};

			foreach (var m in variants)
			{
				_ = XGrabKey(xDisplay, keycode, m, xRoot, true, GrabModeAsync, GrabModeAsync);
				sink.Add((keycode, m));
			}
			XSync(xDisplay, false);
		}

		private static readonly uint[] ExtraGrabMasks = { ControlMask, ShiftMask, Mod1Mask, Mod4Mask, Mod5Mask };

		private void GrabKeyWithExtraModifiers(int keycode, uint baseMods)
		{
			if (!IsX11Available) return;

			uint[] baseVariants =
			{
				baseMods,
				baseMods | LockMask,
				baseMods | Mod2Mask,
				baseMods | LockMask | Mod2Mask
			};

			var seen = new HashSet<uint>();

			foreach (var variant in baseVariants)
			{
				// All combinations of extra modifiers (Ctrl/Alt/Super/Shift/AltGr)
				int comboCount = 1 << ExtraGrabMasks.Length;
				for (int maskBits = 0; maskBits < comboCount; maskBits++)
				{
					uint mods = variant;
					for (int i = 0; i < ExtraGrabMasks.Length; i++)
					{
						if ((maskBits & (1 << i)) != 0)
							mods |= ExtraGrabMasks[i];
					}

					if (!seen.Add(mods))
						continue;

					_ = XGrabKey(xDisplay, keycode, mods, xRoot, true, GrabModeAsync, GrabModeAsync);
					activeGrabs.Add((keycode, mods));
				}
			}

			XSync(xDisplay, false);
		}

		private void UngrabAll()
		{
			if (!IsX11Available) return;

			foreach (var (kc, mods) in activeGrabs)
				_ = XUngrabKey(xDisplay, kc, mods, xRoot);
			activeGrabs.Clear();
			XSync(xDisplay, false);
		}

		private void UngrabDynamic()
		{
			if (!IsX11Available)
			{
				activeDynamicGrabs.Clear();
				return;
			}

			foreach (var (kc, mods) in activeDynamicGrabs)
			{
				// If this grab is also part of the static grab set, leave it in place.
				bool shared = false;
				foreach (var (gkc, gmods) in activeGrabs)
				{
					if (gkc == kc && gmods == mods) { shared = true; break; }
				}

				if (!shared)
					_ = XUngrabKey(xDisplay, kc, mods, xRoot);
			}
			activeDynamicGrabs.Clear();
			XSync(xDisplay, false);
		}

		// -------------------- KeySym mapping for XGrabKey --------------------
		private const uint Mod5Mask = 1 << 7; // Usually ISO_Level3_Shift (AltGr) on X11

		private static ulong VkToKeysym(uint vk)
		{
			// Letters / digits: ASCII KeySym
			if (vk >= 'A' && vk <= 'Z') return vk;
			if (vk >= '0' && vk <= '9') return vk;

			// A few core keys; extend as needed.
			return vk switch
			{
				VK_RETURN => XStringToKeysym("Return"),
				VK_TAB => XStringToKeysym("Tab"),
				VK_ESCAPE => XStringToKeysym("Escape"),
				VK_SPACE => XStringToKeysym("space"),
				VK_LEFT => XStringToKeysym("Left"),
				VK_RIGHT => XStringToKeysym("Right"),
				VK_UP => XStringToKeysym("Up"),
				VK_DOWN => XStringToKeysym("Down"),

				// OEM punctuation (base physical keys)
				VK_OEM_MINUS => XStringToKeysym("minus"),
				VK_OEM_PLUS => XStringToKeysym("equal"),
				VK_OEM_4 => XStringToKeysym("bracketleft"),
				VK_OEM_6 => XStringToKeysym("bracketright"),
				VK_OEM_5 => XStringToKeysym("backslash"),
				VK_OEM_1 => XStringToKeysym("semicolon"),
				VK_OEM_7 => XStringToKeysym("apostrophe"),
				VK_OEM_COMMA => XStringToKeysym("comma"),
				VK_OEM_PERIOD => XStringToKeysym("period"),
				VK_OEM_2 => XStringToKeysym("slash"),
				VK_OEM_3 => XStringToKeysym("grave"),

				_ when (vk >= VK_F1 && vk <= VK_F24)
					=> XStringToKeysym($"F{(int)(vk - VK_F1 + 1)}"),

				_ => 0
			};
		}

		// Minimal reverse mapping for startup keymap sync (modifiers + common keys).
		private static uint VkFromKeysym(ulong ks)
		{
			// ASCII letters/digits.
			if ((ks >= 'A' && ks <= 'Z') || (ks >= 'a' && ks <= 'z'))
				return (uint)char.ToUpperInvariant((char)ks);
			if (ks >= '0' && ks <= '9')
				return (uint)ks;

			return ks switch
			{
				0xFFE1 => VK_LSHIFT,   // Shift_L
				0xFFE2 => VK_RSHIFT,   // Shift_R
				0xFFE3 => VK_LCONTROL, // Control_L
				0xFFE4 => VK_RCONTROL, // Control_R
				0xFFE9 => VK_LMENU,    // Alt_L
				0xFFEA => VK_RMENU,    // Alt_R
				0xFFEB => VK_LWIN,     // Super_L
				0xFFEC => VK_RWIN,     // Super_R
				0xFF0D => VK_RETURN,   // Return
				0xFF09 => VK_TAB,      // Tab
				0xFF1B => VK_ESCAPE,   // Escape
				0x0020 => VK_SPACE,    // space
				0xFF51 => VK_LEFT,
				0xFF53 => VK_RIGHT,
				0xFF52 => VK_UP,
				0xFF54 => VK_DOWN,
				0x002D => VK_OEM_MINUS,
				0x003D => VK_OEM_PLUS,
				0x005B => VK_OEM_4,
				0x005D => VK_OEM_6,
				0x005C => VK_OEM_5,
				0x003B => VK_OEM_1,
				0x0027 => VK_OEM_7,
				0x002C => VK_OEM_COMMA,
				0x002E => VK_OEM_PERIOD,
				0x002F => VK_OEM_2,
				0x0060 => VK_OEM_3,
				_ => 0
			};
		}

		const uint XkbUseCoreKbd = 0x0100;   // you already used this
		const uint XK_Num_Lock = 0xff7f;
		const uint XK_Scroll_Lock = 0xff14;

		internal bool TryGetIndicatorStates(out bool capsOn, out bool numOn, out bool scrollOn)
		{
			capsOn = numOn = scrollOn = false;
			var display = xDisplay != IntPtr.Zero ? xDisplay : XOpenDisplay(IntPtr.Zero);
			var openedHere = display != IntPtr.Zero && display != xDisplay;
			if (display == IntPtr.Zero) return false;

			try
			{
				if (XkbGetState(display, XkbUseCoreKbd, out var st) != 0)
					return false;

				// Caps: test the locked 'Lock' modifier
				capsOn = (st.locked_mods & (byte)LockMask) != 0;

				// Num/Scroll: ask which modifier mask those keysyms map to, then test locked_mods
				var numMask = XkbKeysymToModifiers(display, XK_Num_Lock);
				var scrollMask = XkbKeysymToModifiers(display, XK_Scroll_Lock);

				numOn = (st.locked_mods & (byte)numMask) != 0;
				scrollOn = (st.locked_mods & (byte)scrollMask) != 0;
				return true;
			}
			finally
			{
				if (openedHere) XCloseDisplay(display);
			}
		}

		// -------------------- X11 P/Invoke --------------------

		private const string X11 = "libX11.so.6";
		private const string Xtst = "libXtst.so.6";

		private const ulong CurrentTime = 0UL;  // Xlib constant

		private const int GrabModeAsync = 1;
		private const uint AnyModifier = 1 << 15;
		private const uint ShiftMask = 1 << 0;
		private const uint LockMask = 1 << 1;
		private const uint ControlMask = 1 << 2;
		private const uint Mod1Mask = 1 << 3; // Alt
		private const uint Mod2Mask = 1 << 4; // often NumLock
		private const uint Mod4Mask = 1 << 6; // Super/Win

		[DllImport(X11)] private static extern IntPtr XOpenDisplay(IntPtr name);
		[DllImport(X11)] private static extern IntPtr XDefaultRootWindow(IntPtr display);
		[DllImport(X11)] private static extern int XGrabKey(IntPtr display, int keycode, uint modifiers, IntPtr grab_window, bool owner_events, int pointer_mode, int keyboard_mode);
		[DllImport(X11)] private static extern int XUngrabKey(IntPtr display, int keycode, uint modifiers, IntPtr grab_window);
		[DllImport(X11)] private static extern int XKeysymToKeycode(IntPtr display, IntPtr keysym);
		[DllImport(X11)] private static extern int XKeycodeToKeysym(IntPtr display, int keycode, int index);
		[DllImport(X11)] private static extern int XQueryKeymap(IntPtr display, byte[] keys_return);
		[DllImport(X11)] private static extern ulong XStringToKeysym(string str);
		[DllImport(X11)] private static extern int XSync(IntPtr display, bool discard);
		[DllImport(X11)] private static extern int XUngrabKeyboard(IntPtr display, ulong time);
		[DllImport(X11)] private static extern int XFlush(IntPtr display);
		[DllImport(X11)] private static extern int XkbGetIndicatorState(IntPtr display, uint device_spec, out uint state_return);
		[StructLayout(LayoutKind.Sequential)]
		private struct XKeyboardState { public int key_click_percent, bell_percent, bell_pitch, bell_duration, led_mask; /* rest omitted */ }
		[DllImport(X11)] private static extern int XGetKeyboardControl(IntPtr display, out XKeyboardState state);
		[DllImport(X11)] static extern int XkbGetState(IntPtr dpy, uint deviceSpec, out XkbStateRec state);
		[DllImport(X11)] static extern uint XkbKeysymToModifiers(IntPtr dpy, uint keysym);

		[StructLayout(LayoutKind.Sequential)]
		struct XkbStateRec
		{
			public byte group, locked_group;
			public ushort base_group, latched_group;
			public byte mods, base_mods, latched_mods, locked_mods;
			public byte compat_state, grab_mods, compat_grab_mods, lookup_mods, compat_lookup_mods;
			public ushort ptr_buttons;
		}

		[DllImport(X11)] private static extern int XCloseDisplay(IntPtr display);

		[DllImport(Xtst)] private static extern int XTestFakeKeyEvent(IntPtr display, int keycode, bool is_press, ulong delay);
	}
}
#endif
