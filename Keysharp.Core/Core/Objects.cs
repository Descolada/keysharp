namespace Keysharp.Core
{
	/// <summary>
	/// Public interface for Obj*() functions.
	/// </summary>
	public static class Objects
	{
		/// <summary>
		/// Creates a new <see cref="Map"/> object.
		/// This can be called manually by the script or be generated by the parser
		/// for object literal construction like:
		/// val := { one : 1 }
		/// Note that the map must be case insensitive so that property lookups like:
		/// val.one and val.One both work.
		/// </summary>
		/// <param name="args">The optional data to initialize the <see cref="Map"/> with. This can be:
		///     An existing <see cref="Map"/> object.
		///     An <see cref="Array"/> of key,value pairs.
		///     An existing <see cref="Dictionary{string, object}"/> object.
		///     An object[] of key,value pairs.
		/// </param>
		/// <returns>A new <see cref="Map"/> object.</returns>
		public static KeysharpObject Object(params object[] args)
		{
			var kso = new KeysharpObject();
			var count = (args.Length / 2) * 2;

			for (var i = 0; i < count; i += 2)
			{
				var map = new Map(false)
				{
					CaseSense = false
				};
				var key = args[i].ToString();

				if (string.Compare(key, "get", true) == 0
						|| string.Compare(key, "set", true) == 0
						|| string.Compare(key, "call", true) == 0)
				{
					map[key.ToLower()] = args[i + 1];
				}
				else
					map["value"] = args[i + 1];

				_ = kso.DefineProp(key, map);
			}

			return kso;
		}

		/// <summary>
		/// Unsupported.
		/// </summary>
		/// <param name="obj">Ignored.</param>
		/// <returns>None</returns>
		/// <exception cref="Error">An <see cref="Error"/> exception is thrown because this function has no meaning in Keysharp.</exception>
		public static object ObjGetCapacity(object obj)
		{
			Error err;

			if (obj is KeysharpObject kso)
				return kso.GetCapacity();

			return Errors.ErrorOccurred(err = new Error($"Object of type {obj.GetType()} was not of type KeysharpObject.")) ? throw err : null;
		}

		/// <summary>
		/// Returns whether an object contains an OwnProp by the specified name.
		/// </summary>
		/// <param name="obj">The obj to search for an OwnProp on.</param>
		/// <param name="name">The OwnProp name to search for.</param>
		/// <returns>Returns 1 if an object owns a property by the specified name, otherwise 0.</returns>
		/// <exception cref="Error">An <see cref="Error"/> exception is thrown if obj was not of type KeysharpObject.</exception>
		public static long ObjHasOwnProp(object obj, object name) => obj is KeysharpObject kso ? kso.HasOwnProp(name) : 0L;

		/// <summary>
		/// Returns the number of properties owned by an object.
		/// </summary>
		/// <param name="obj">The object to get the OwnProps count for.</param>
		/// <returns>The number of properties owned by an obj.</returns>
		/// <exception cref="Error">An <see cref="Error"/> exception is thrown if obj was not of type KeysharpObject.</exception>
		public static long ObjOwnPropCount(object obj)
		{
			Error err;

			if (obj is KeysharpObject kso)
				return kso.OwnPropCount();

			return Errors.ErrorOccurred(err = new Error($"Object of type {obj.GetType()} was not of type KeysharpObject.")) ? throw err : 0L;
		}

		/// <summary>
		/// Returns an OwnProps iterator for the given object.
		/// </summary>
		/// <param name="obj">The object whose OwnProps will be retrieved.</param>
		/// <param name="userOnly">Optionally pass true to specify only user props, else false return all. Default: true.</param>
		/// <returns>An <see cref="OwnPropsIterator"/> object for obj.</returns>
		/// <exception cref="Error">An <see cref="Error"/> exception is thrown if obj was not of type KeysharpObject.</exception>
		public static object ObjOwnProps(object obj, object userOnly = null)
		{
			Error err;

			if (obj is KeysharpObject kso)
				return kso.OwnProps(userOnly);

			return Errors.ErrorOccurred(err = new Error($"Object of type {obj.GetType()} was not of type KeysharpObject.")) ? throw err : null;
		}

		/// <summary>
		/// Unsupported.
		/// </summary>
		/// <param name="obj">Ignored</param>
		/// <exception cref="Error">An <see cref="Error"/> exception is thrown because this function has no meaning in Keysharp.</exception>
		public static object ObjSetBase(params object[] obj)
		{
			Error err;
			return Errors.ErrorOccurred(err = new Error(Any.BaseExc)) ? throw err : null;
		}

		/// <summary>
		/// Unsupported.
		/// </summary>
		/// <param name="obj0">Ignored</param>
		/// <param name="obj1">Ignored</param>
		/// <returns>None</returns>
		/// <exception cref="Error">An <see cref="Error"/> exception is thrown because this function has no meaning in Keysharp.</exception>
		public static object ObjSetCapacity(object obj0, object obj1)
		{
			Error err;

			if (obj0 is KeysharpObject kso)
				return kso.SetCapacity(obj1);

			return Errors.ErrorOccurred(err = new Error($"Object of type {obj0.GetType()} was not of type KeysharpObject.")) ? throw err : null;
		}

		// Shared helper to normalize an “object” that might be
		// an IntPtr, a long, or a RCW wrapper into a raw IUnknown*.
		private static nint GetRawIUnknownPtr(object ptrOrObj)
		{
			if (ptrOrObj is long l)               // pointer encoded as a long
				return (nint)l;

			// must be a CCW/RCW object:
			// 1) GetIUnknownForObject adds 1 ref
			// 2) Release immediately drops it back to original count
			nint punk = Marshal.GetIUnknownForObject(ptrOrObj);
			Marshal.Release(punk);
			return punk;
		}

		/// <summary>
		/// Returns an IntPtr that represents the given object.
		/// The resulting GCHandle is allocated with GCHandleType.Normal,
		/// so it must be freed later to avoid a leak.
		/// </summary>
		public static long ObjPtr(object obj)
		{
			if (obj == null)
				return 0;

			return GetRawIUnknownPtr(obj);
		}
		public static long ObjPtrAddRef(object obj)
		{
			if (obj == null)
				return 0;

			// GetIUnknownForObject always adds one ref
			return Marshal.GetIUnknownForObject(obj);
		}

		/// <summary>
		/// Given an IntPtr produced by ObjPtr, returns the original object.
		/// </summary>
		public static object ObjFromPtr(object ptr)
		{
			ptr = Reflections.GetPtrProperty(ptr);

			nint punk = GetRawIUnknownPtr(ptr);
			if (punk == 0)
				return null;

			// For COM object this creates or finds the RCW and bumps the ref count,
			// and once the object is collected then the ref count is decreased.
			// If it's a managed object then it's just returned (I think, this is unverified).
			var dispPtr = Marshal.GetObjectForIUnknown(punk);

			if (dispPtr is IDispatch id)
				return new ComObject(VarEnum.VT_DISPATCH, id);
			else if (Marshal.IsComObject(dispPtr))
				return new ComObject(VarEnum.VT_UNKNOWN, dispPtr);
			else
				return dispPtr;
		}

		// Mostly for compatibility with AHK
		public static object ObjFromPtrAddRef(object ptr)
		{
			ptr = Reflections.GetPtrProperty(ptr);

			nint punk = GetRawIUnknownPtr(ptr);
			if (punk == 0)
				return null;

			// bump the COM ref-count
			Marshal.AddRef(punk);

			// then unwrap to RCW
			return Marshal.GetObjectForIUnknown(punk);
		}

		/// <summary>
		/// Frees a managed C# object or string, allowing it to be garbage-collected.
		/// </summary>
		public static bool ObjFree(object value)
		{
			Error err;

			if (value is IPointable ip)
				value = ip.Ptr;

			if (Marshal.IsComObject(value))
			{
				Marshal.ReleaseComObject(value);
				return true;
			} 
			else if (value is long l) 
			{
				if (Script.TheScript.StringsData.gcHandles.Remove((nint)l, out var oldGch))
				{
					oldGch.Free();
					return true;
				}
				Marshal.Release((nint)l);
				return true;
			} 
			else
				return Errors.ErrorOccurred(err = new TypeError($"Argument of type {value.GetType()} was not a pointer.")) ? throw err : false;
		}
	}
}