; def := 123
; m := Map()
; x := m.Default
; x := m . def
; x := m[def]
; x := m["def"]
; x := m["Default"]
; ; m.Default := 123
; x123 := 456
; y := x%def%
; y := m.x%def%



AddHotstring("::yt", null, ":yt", "yt", "Any text between the top and bottom parentheses is treated literally.\nBy default," +
							 " the hard carriage return (Enter) between the previous line and this one is also" +
							 " preserved.\n    By default, the indentation (tab) to the left of this line is pr" +
							 "eserved.", true);
							 
							 A2089485825
							 
							 
n :=
left :=
right :=
top :=
bottom :=

n := MonitorGet(n, &left, &Top, &Right, &Bottom)


fo = Func("MonitorGet");
{
	var tempobj = RefsToObjArray(n, left, top, right, bottom);
	((IFuncObj)fo).Call(tempobj);
	ObjArrayToRefs(tempobj, ref n, ref left, ref top, ref right, ref bottom);
}

monget := MonitorGet(1)
fo := FuncObj("MonitorGet")
monget := fo(1)
monget := fo.Call(1)

x := 123

func()
{
z := x
}



sections done for params args:
	-drive
	-environment
	-file and directory
	-math
	-misc
	-monitor
	-mouse and keyboard
	-process
	-registry
	-screen
	-sounds
	-strings
	
sections to do for params args:
	-external libraries
	-flow of control
	-gui: reworked events, so will need extensive testing
	

before committing, write unit tests for:
	variadic params
	RegRead throwing an exception when key not found, and returning def when not found but def supplied
	run all unit tests
	do funcobj and boundfunc with more, less, and equal args than the function they are pointing to. also test variadic funcs: send variadic to variadic, variadic to non variadic, and non variadic to variadic.
	loop where you alter A_Index inside of the loop
	