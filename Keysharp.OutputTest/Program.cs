using static Keysharp.Core.Accessors;
using static Keysharp.Core.Core;
//using static Keysharp.Core.Common.Window.WindowItemBase;
using static Keysharp.Core.Dialogs;
using static Keysharp.Core.Disk;
using static Keysharp.Core.DllHelper;
using static Keysharp.Core.Env;
using static Keysharp.Core.Flow;
using static Keysharp.Core.Function;
using static Keysharp.Core.GuiHelper;
using static Keysharp.Core.Images;
using static Keysharp.Core.ImageLists;
using static Keysharp.Core.Ini;
using static Keysharp.Core.Keyboard;
using static Keysharp.Core.KeysharpObject;
using static Keysharp.Core.Loops;
using static Keysharp.Core.Maths;
using static Keysharp.Core.Menu;
using static Keysharp.Core.Misc;
using static Keysharp.Core.Monitor;
using static Keysharp.Core.Mouse;
using static Keysharp.Core.Network;
using static Keysharp.Core.Options;
using static Keysharp.Core.Processes;
using static Keysharp.Core.Registrys;
using static Keysharp.Core.Screen;
using static Keysharp.Core.Security;
using static Keysharp.Core.SimpleJson;
using static Keysharp.Core.Sound;
using static Keysharp.Core.Strings;
using static Keysharp.Core.ToolTips;
using static Keysharp.Core.Window;
using static Keysharp.Core.Windows.WindowsAPI;
using static Keysharp.Scripting.Script;
using static Keysharp.Scripting.Script.Operator;
using System.Threading.Channels;
using System.Threading.Tasks;
using System.Threading;

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

[assembly: System.CLSCompliantAttribute(true)]
[assembly: Keysharp.Scripting.AssemblyBuildVersionAttribute("0.0.0.1")]

namespace Keysharp.Main
{
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Data;
	using System.Diagnostics;
	using System.IO;
	using System.Reflection;
	using System.Runtime.InteropServices;
	using System.Text;
	using System.Windows.Forms;
	using Keysharp.Core;
	using Keysharp.Scripting;
	using Array = Keysharp.Core.Array;
	using Buffer = Keysharp.Core.Buffer;


	public sealed class Program
	{
		private const int WH_KEYBOARD_LL = 13;
		private const int WM_KEYDOWN = 0x0100;
		private static LowLevelKeyboardProc _proc = HookCallback;
		private static IntPtr _hookID = IntPtr.Zero;

		private static IntPtr SetHook(LowLevelKeyboardProc proc)
		{
			using (Process curProcess = Process.GetCurrentProcess())
				using (ProcessModule curModule = curProcess.MainModule)
				{
					return SetWindowsHookEx(WH_KEYBOARD_LL, proc,
											GetModuleHandle(curModule.ModuleName), 0);
				}
		}

		private delegate IntPtr LowLevelKeyboardProc(
			int nCode, IntPtr wParam, IntPtr lParam);

		private static IntPtr HookCallback(
			int nCode, IntPtr wParam, IntPtr lParam)
		{
			if (nCode >= 0 && wParam == (IntPtr)WM_KEYDOWN)
			{
				int vkCode = Marshal.ReadInt32(lParam);
				System.Diagnostics.Debug.WriteLine((Keys)vkCode);
			}

			return CallNextHookEx(_hookID, nCode, wParam, lParam);
		}

		[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		private static extern IntPtr SetWindowsHookEx(int idHook,
				LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);

		[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		private static extern bool UnhookWindowsHookEx(IntPtr hhk);

		[DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode,
				IntPtr wParam, IntPtr lParam);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
		private static extern IntPtr GetModuleHandle(string lpModuleName);

		public static Task StartSTATask(Action func)
		{
			var _tcs = new TaskCompletionSource<object>();
			var thread = new Thread((t) =>
			{
				var tcs = t as TaskCompletionSource<object>;

				try
				{
					func();
					tcs.SetResult(null);
				}
				catch (Exception e)
				{
					tcs.SetException(e);
				}
			});
			thread.SetApartmentState(ApartmentState.STA);
			thread.Start(_tcs);
			return _tcs.Task;
		}

		public static Thread StartSTAThread(Action func)
		{
			var thread = new Thread(() =>
			{
				try
				{
					func();
				}
				catch (Exception ex)
				{
					//Instance.LogError($"Exception in {new StackFrame(0).GetMethod().Name}()", "StartSTAThread", ex);
				}
			});
			thread.SetApartmentState(ApartmentState.STA);
			thread.Start();
			return thread;
		}

		[System.STAThreadAttribute()]
		public static int Main(string[] args)
		{
			try
			{
				//Task.Factory.StartNew(() =>
				//var th = new System.Threading.Thread(() =>
				//{
				//  _hookID = SetHook(_proc);
				//  Application.Run();
				//});
				//th.SetApartmentState(System.Threading.ApartmentState.STA);
				//th.Start();
				//Application.Run();
				//UnhookWindowsHookEx(_hookID);
				string name = @"*";
				Keysharp.Scripting.Script.Variables.InitGlobalVars();
				Keysharp.Scripting.Script.SetName(name);
				HandleSingleInstance(name, eScriptInstance.Off);
				HandleCommandLineParams(args);
				SetProcessDPIAware();
				CreateTrayMenu();
				Hotstring("::btw", "by the way");
				RunMainWindow(name);
				ExitApp(0);
				return 0;
			}
			catch (Keysharp.Core.Error kserr)
			{
				if (ErrorOccurred(kserr))
				{
					MsgBox("Uncaught Keysharp exception:\r\n" + kserr);
				}

				ExitApp(1);
				return 1;
			}
			catch (System.Exception mainex)
			{
				MsgBox("Uncaught exception:\r\n" + "Message: " + mainex.Message + "\r\nStack: " + mainex.StackTrace);
				ExitApp(1);
				return 1;
			}
		}

		public static object x;
	}
}
